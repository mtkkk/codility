Algorithms

-Converter ArrayList para Array tipo primitivo
	myList.stream().mapToInt(Integer::valueOf).toArray();

-Converter lista de tipo primitivo para List<T>
	Arrays.asList(A);

-Adicionar um numero a uma lista e verificar se está na lista

	HashSet<Integer> dups = new HashSet<Integer>();
	if (dups.add(A[i])){}

-Preencher um array inteiro com um determinado valor
	
	Arrays.fill(A[], valor)



-Rotacionar um número inteiro
	
	// Rotate function to right rotate the number 
    static int Rotate(int n) 
    { 
        int rem = n % 10; // find unit place number 
        rem *= Math.pow(10, countDigits(n)); // to put unit place 
        // number as first digit. 
        n /= 10; // remove unit digit 
        n += rem; // add first digit to rest 
        return n; 
    } 		

    // Function to find total number of digits 
    static int countDigits(int n) 
    { 
        int digit = 0; 
        while ((n /= 10) > 0) 
            digit++; 
        return digit; 
    } 


-Guardando valores (ex: quantas vezes um numero apareceu no array)	
	Map<Integer,Integer> counter = new HashMap<Integer,Integer>();
	for(Entry<Integer,Integer> nOccurrences : counter.entrySet()){
	}


*******************************************************************
*****************************SORTING*******************************
*******************************************************************	

-Bubble Sort
	for(int i = array.length-1 ; i >= 1 ; i--){
		for(int j = 0; j <= i-1 ; j++){
			if(array[j] > array[j+1]){
				swap(array,j,j+1);
			}
		}
	}



*******************************************************************
**************************MATH CONCEPTS****************************
*******************************************************************

-Maximum number of combinations
	->Unordered, no repetition
		n = array size
		r = numbers chosen (2 for pairs, 3 for triplets)
		n! / r!(n-r)!	=> 	
		maxCombinations = n * (n-1) / 2

-Descobrir quantidade de números divisíveis por K
	int lowerBound, int higherBound, int K
	(higherBound/K) - (lowerBound/K) + lowerBound % K == 0 ? 1 : 0		


*******************************************************************
**************************PRIME NUMBERS****************************
*******************************************************************	

-Achar todos os numeros primos 
	
	Preencher um array de boolean e ir "desmarcando(false)"	 aqueles que não são primos. 
	Algoritmo de Eratosthenes -> 
		boolean primeCheck[] = new boolean[N+1];
		Arrays.fill(primeCheck, true);
		for(int i = 2 ; i*i <= N ; i++){
			if(primeCheck[i]){ //Checks if hasnt been marked
				for(int j = i*2 ; j <= N ; j += i){
					primeCheck[j] = false;
				}
			}
		}

*******************************************************************
***************************GCD AND LCM*****************************
*******************************************************************	

NOTA*** GCD (Greatest Common Divisor) ou GCF(Greatest Common Factor) é o MDC(Máximo Divisor Comum)
		LCM (Least Common Multiple) é o MDC(Mínimo Múltiplo Comum)

-Euclidean Algorithm (GCD)
	public static int gcd(int a, int b){
		if(a % b == 0){
			return b;
		} else {
			return gcd(b, a % b);
		}
	}

-LCM
	int lcm = A*B / gcd(A,B);